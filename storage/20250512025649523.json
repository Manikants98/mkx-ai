[
  {
    "role": "system",
    "content": "\n  You are a professional interactive personal tutor who is an expert at explaining topics to student as a teacher. Given a topic and the information to teach, please educate the user about it, who is a student. The learner here is a student of high school between the age of 15 and 18 years. Do not quiz or ask any question. Only give your answer. Start by greeting the learner, giving them a short overview of the topic, and then ask them what they want to learn about (in markdown numbers). Be interactive throughout the chat and quiz the user occasionally after you teach them material. Do not quiz them in the first overview message and make the first message short and concise.\n\n  Right now the information to teach the student is about ===\n\n  <teaching_info>\n  \n\n  ## Webpage #0:\n React useEffect Hooks \nThe useEffect Hook allows you to perform side effects in your components. Some examples of side effects are: fetching data, directly updating the DOM, and timers. useEffect accepts two arguments. The second argument is optional. useEffect(<function>, <dependency>) \nLet's use a timer as an example. \nExample:\n  Use setTimeout() to count 1 second after initial render:\nimport { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom/client\"; function Timer() {\n  const [count, setCount] = useState(0);  useEffect(() => {\n  setTimeout(() => {\n  setCount((count) => count + 1);\n  }, 1000);\n  });  return <h1>I've rendered {count} times!</h1>;\n} const root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Timer />); Run \nExample ¬ª \nBut wait!! It keeps counting even though it should only count once! useEffect runs on every render. That means that when the count changes, a render happens, which then triggers another effect. This is not what we want. There are several ways to control when side effects run. We should always include the second parameter which accepts an array.\nWe can optionally pass dependencies to useEffect in this array. \nExample\n1. No dependency passed:\nuseEffect(() => {\n  //Runs on every render\n}); \nExample\n2. An empty array:\nuseEffect(() => {\n  //Runs only on the first render\n}, []); \nExample\n3. Props or state values:\nuseEffect(() => {\n  //Runs on the first render\n  //And any time any dependency value changes\n}, [prop, state]); \nSo, to fix this issue, let's only run this effect on the initial render. \nExample:\n  Only run the effect on the initial render:\nimport { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom/client\"; function Timer() {\n  const [count, setCount] = useState(0);  useEffect(() => {\n  setTimeout(() => {\n  setCount((count) => count + 1);\n  }, 1000);\n  }, []); // <- add empty brackets here  return <h1>I've rendered {count} times!</h1>;\n} const root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Timer />); Run \nExample ¬ª \nExample:\n  Here is an example of a useEffect Hook that is dependent on a variable. If the count variable updates, the effect will run again:\nimport { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom/client\"; function Counter() {\n  const [count, setCount] = useState(0);\n  const [calculation, setCalculation] = useState(0);  useEffect(() => {\n  setCalculation(() => count * 2);\n  }, [count]); // <- add the count variable here  return (\n  <>\n  <p>Count: {count}</p>\n  <button onClick={() => setCount((c) => c + 1)}>+</button>\n  <p>Calculation: {calculation}</p>\n  </>\n  );\n} const root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Counter />); Run \nExample ¬ª \nIf there are multiple dependencies, they should be included in the useEffect dependency array. \nEffect Cleanup\nSome effects require cleanup to reduce memory leaks. Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed. We do this by including a return function at the end of the useEffect Hook. Example:\n  Clean up the timer at the end of the useEffect Hook:\nimport { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom/client\"; function Timer() {\n  const [count, setCount] = useState(0);  useEffect(() => {\n  let timer = setTimeout(() => {\n  setCount((count) => count + 1);\n  }, 1000);  return () => clearTimeout(timer)\n  }, []);  return <h1>I've rendered {count} times!</h1>;\n} const root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Timer />); Run \nExample ¬ª \nNote: To clear the timer, we had to name it. \n  ‚òÖ  +1\n  Track your progress - it's free! \n\n,## Webpage #1:\n useEffect is a React Hook that lets you synchronize a component with an external system.useEffect(setup, dependencies?)\nReference useEffect(setup, dependencies?) Usage Connecting to an external system Wrapping Effects in custom Hooks Controlling a non-React widget Fetching data with Effects Specifying reactive dependencies Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect Displaying different content on the server and the client Troubleshooting My Effect runs twice when the component mounts My Effect runs after every re-render My Effect keeps re-running in an infinite cycle My cleanup logic runs even though my component didn‚Äôt unmount My Effect does something visual, and I see a flicker before it runs  Reference \nuseEffect(setup, dependencies?) \nCall useEffect at the top level of your component to declare an Effect:\nimport { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);// ...}\nSee more examples below.\nParameters  \nsetup: The function with your Effect‚Äôs logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. \noptional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all. \nReturns \nuseEffect returns undefined.\nCaveats  \nuseEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it. \nIf you‚Äôre not trying to synchronize with some external system, you probably don‚Äôt need an Effect. \nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. \nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. \nIf your Effect wasn‚Äôt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect. \nIf your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information. \nEven if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect. \nEffects only run on the client. They don‚Äôt run during server rendering. \nUsage \nConnecting to an external system \nSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren‚Äôt controlled by React, so they are called external.\nTo connect your component to some external system, call useEffect at the top level of your component:\nimport { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);// ...}\nYou need to pass two arguments to useEffect: A setup function with setup code that connects to that system. It should return a cleanup function with cleanup code that disconnects from that system. \nA list of dependencies including every value from your component used inside of those functions. React calls your setup and cleanup functions whenever it‚Äôs necessary, which may happen multiple times: Your setup code runs when your component is added to the page (mounts).\nAfter every re-render of your component where the dependencies have changed: First, your cleanup code runs with the old props and state.\nThen, your setup code runs with the new props and state. \nYour cleanup code runs one final time after your component is removed from the page (unmounts). Let‚Äôs illustrate this sequence for the example above.\nWhen the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time.\nTo help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development). See common solutions.\nTry to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn‚Äôt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly ‚Äúmirrors‚Äù the setup logic, your Effect is resilient to running setup and cleanup as often as needed. Example 1 of 5: Connecting to a chat server In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press ‚ÄúOpen chat‚Äù to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press ‚ÄúClose chat‚Äù to see the Effect disconnect one last time.import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js'; function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {\n  const connection = createConnection(serverUrl, roomId);\n  connection.connect();\n  return () => {\n  connection.disconnect();\n  };\n  }, [roomId, serverUrl]);  return (\n  <>\n  <label>\n  Server URL:{' '}\n  <input\n  value={serverUrl}\n  onChange={e => setServerUrl(e.target.value)}\n  />\n  </label>\n  <h1>Welcome to the {roomId} room!</h1>\n  </>\n  );\n} export default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n  <>\n  <label>\n  Choose the chat room:{' '}\n  <select\n  value={roomId}\n  onChange={e => setRoomId(e.target.value)}\n  >\n  <option value=\"general\">general</option>\n  <option value=\"travel\">travel</option>\n  <option value=\"music\">music</option>\n  </select>\n  </label>\n  <button onClick={() => setShow(!show)}>\n  {show ? 'Close chat' : 'Open chat'}\n  </button>\n  {show && <hr />}\n  {show && <ChatRoom roomId={roomId} />}\n  </>\n  );\n} \nWrapping Effects in custom Hooks \nEffects are an ‚Äúescape hatch‚Äù: you use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it‚Äôs usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.\nFor example, this useChatRoom custom Hook ‚Äúhides‚Äù the logic of your Effect behind a more declarative API:\nfunction useChatRoom({ serverUrl, roomId }) {useEffect(() => {const options = {serverUrl: serverUrl,roomId: roomId};const connection = createConnection(options);connection.connect();return () => connection.disconnect();}, [roomId, serverUrl]);}\nThen you can use it from any component like this:\nfunction ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useChatRoom({roomId: roomId,serverUrl: serverUrl});// ...\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\nLearn more about wrapping Effects in custom Hooks.\nExample 1 of 3: Custom useChatRoom Hook This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js'; function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({\n  roomId: roomId,\n  serverUrl: serverUrl\n  });  return (\n  <>\n  <label>\n  Server URL:{' '}\n  <input\n  value={serverUrl}\n  onChange={e => setServerUrl(e.target.value)}\n  />\n  </label>\n  <h1>Welcome to the {roomId} room!</h1>\n  </>\n  );\n} export default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n  <>\n  <label>\n  Choose the chat room:{' '}\n  <select\n  value={roomId}\n  onChange={e => setRoomId(e.target.value)}\n  >\n  <option value=\"general\">general</option>\n  <option value=\"travel\">travel</option>\n  <option value=\"music\">music</option>\n  </select>\n  </label>\n  <button onClick={() => setShow(!show)}>\n  {show ? 'Close chat' : 'Open chat'}\n  </button>\n  {show && <hr />}\n  {show && <ChatRoom roomId={roomId} />}\n  </>\n  );\n} \nControlling a non-React widget \nSometimes, you want to keep an external system synchronized to some prop or state of your component.\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized:\nimport { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js'; export default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);  useEffect(() => {\n  if (mapRef.current === null) {\n  mapRef.current = new MapWidget(containerRef.current);\n  }  const map = mapRef.current;\n  map.setZoom(zoomLevel);\n  }, [zoomLevel]);  return (\n  <div\n  style={{ width: 200, height: 200 }}\n  ref={containerRef}\n  />\n  );\n} \nIn this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine. Fetching data with Effects \nYou can use an Effect to fetch data for your component. Note that if you use a framework, using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually.\nIf you want to fetch data from an Effect manually, your code might look like this:\nimport { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {const [person, setPerson] = useState('Alice');const [bio, setBio] = useState(null);useEffect(() => {let ignore = false;setBio(null);fetchBio(person).then(result => {if (!ignore) {setBio(result);}});return () => {ignore = true;};}, [person]);// ...\nNote the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù: network responses may arrive in a different order than you sent them.\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js'; export default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n  let ignore = false;\n  setBio(null);\n  fetchBio(person).then(result => {\n  if (!ignore) {\n  setBio(result);\n  }\n  });\n  return () => {\n  ignore = true;\n  }\n  }, [person]);  return (\n  <>\n  <select value={person} onChange={e => {\n  setPerson(e.target.value);\n  }}>\n  <option value=\"Alice\">Alice</option>\n  <option value=\"Bob\">Bob</option>\n  <option value=\"Taylor\">Taylor</option>\n  </select>\n  <hr />\n  <p><i>{bio ?? 'Loading...'}</i></p>\n  </>\n  );\n} You can also rewrite using the async / await syntax, but you still need to provide a cleanup function:import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js'; export default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n  async function startFetching() {\n  setBio(null);\n  const result = await fetchBio(person);\n  if (!ignore) {\n  setBio(result);\n  }\n  }  let ignore = false;\n  startFetching();\n  return () => {\n  ignore = true;\n  }\n  }, [person]);  return (\n  <>\n  <select value={person} onChange={e => {\n  setPerson(e.target.value);\n  }}>\n  <option value=\"Alice\">Alice</option>\n  <option value=\"Bob\">Bob</option>\n  <option value=\"Taylor\">Taylor</option>\n  </select>\n  <hr />\n  <p><i>{bio ?? 'Loading...'}</i></p>\n  </>\n  );\n} \nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community.\nDeep DiveWhat are good alternatives to data fetching in Effects? Writing fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\nEffects don‚Äôt run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\nFetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\nFetching directly in Effects usually means you don‚Äôt preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\nIt‚Äôs not very ergonomic. There‚Äôs quite a bit of boilerplate code involved when writing fetch calls in a way that doesn‚Äôt suffer from bugs like race conditions.\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\nIf you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\nOtherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).\nYou can continue fetching data directly in Effects if neither of these approaches suit you. Specifying reactive dependencies \nNotice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect. Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code:\nfunction ChatRoom({ roomId }) { // This is a reactive valueconst [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value toouseEffect(() => {const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive valuesconnection.connect();return () => connection.disconnect();}, [serverUrl, roomId]); // ‚úÖ So you must specify them as dependencies of your Effect// ...}\nIf either serverUrl or roomId change, your Effect will reconnect to the chat using the new values.\nReactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:\nfunction ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, []); // üî¥ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'// ...}\nTo remove a dependency, you need to ‚Äúprove‚Äù to the linter that it doesn‚Äôt need to be a dependency. For example, you can move serverUrl out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders:\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, [roomId]); // ‚úÖ All dependencies declared// ...}\nNow that serverUrl is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ([]):\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, []); // ‚úÖ All dependencies declared// ...}\nAn Effect with empty dependencies doesn‚Äôt re-run when any of your component‚Äôs props or state change.\nPitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() => {// ...// üî¥ Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies don‚Äôt match the code, there is a high risk of introducing bugs. By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. Instead, prove they‚Äôre unnecessary.\nExample 1 of 3: Passing a dependency array If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.useEffect(() => {// ...}, [a, b]); // Runs again if a or b are differentIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isn‚Äôt used in the Effect (and so it isn‚Äôt a dependency), editing the message doesn‚Äôt re-connect to the chat.import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js'; function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n  const [message, setMessage] = useState('');  useEffect(() => {\n  const connection = createConnection(serverUrl, roomId);\n  connection.connect();\n  return () => {\n  connection.disconnect();\n  };\n  }, [serverUrl, roomId]);  return (\n  <>\n  <label>\n  Server URL:{' '}\n  <input\n  value={serverUrl}\n  onChange={e => setServerUrl(e.target.value)}\n  />\n  </label>\n  <h1>Welcome to the {roomId} room!</h1>\n  <label>\n  Your message:{' '}\n  <input value={message} onChange={e => setMessage(e.target.value)} />\n  </label>\n  </>\n  );\n} export default function App() {\n  const [show, setShow] = useState(false);\n  const [roomId, setRoomId] = useState('general');\n  return (\n  <>\n  <label>\n  Choose the chat room:{' '}\n  <select\n  value={roomId}\n  onChange={e => setRoomId(e.target.value)}\n  >\n  <option value=\"general\">general</option>\n  <option value=\"travel\">travel</option>\n  <option value=\"music\">music</option>\n  </select>\n  <button onClick={() => setShow(!show)}>\n  {show ? 'Close chat' : 'Open chat'}\n  </button>\n  </label>\n  {show && <hr />}\n  {show && <ChatRoom roomId={roomId}/>}\n  </>\n  );\n} \nUpdating state based on previous state from an Effect \nWhen you want to update state based on previous state from an Effect, you might run into a problem:\nfunction Counter() {const [count, setCount] = useState(0);useEffect(() => {const intervalId = setInterval(() => {setCount(count + 1); // You want to increment the counter every second...}, 1000)return () => clearInterval(intervalId);}, [count]); // üö© ... but specifying `count` as a dependency always resets the interval.// ...}\nSince count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal.\nTo fix this, pass the c => c + 1 state updater to setCount: Now that you‚Äôre passing c => c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it won‚Äôt need to cleanup and setup the interval again every time the count changes. Removing unnecessary object dependencies \nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render:\nconst serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {const [message, setMessage] = useState('');const options = { // üö© This object is created from scratch on every re-renderserverUrl: serverUrl,roomId: roomId};useEffect(() => {const connection = createConnection(options); // It's used inside the Effectconnection.connect();return () => connection.disconnect();}, [options]); // üö© As a result, these dependencies are always different on a re-render// ...\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');  useEffect(() => {\n  const options = {\n  serverUrl: serverUrl,\n  roomId: roomId\n  };\n  const connection = createConnection(options);\n  connection.connect();\n  return () => connection.disconnect();\n  }, [roomId]);  return (\n  <>\n  <h1>Welcome to the {roomId} room!</h1>\n  <input value={message} onChange={e => setMessage(e.target.value)} />\n  </>\n  );\n} export default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n  <>\n  <label>\n  Choose the chat room:{' '}\n  <select\n  value={roomId}\n  onChange={e => setRoomId(e.target.value)}\n  >\n  <option value=\"general\">general</option>\n  <option value=\"travel\">travel</option>\n  <option value=\"music\">music</option>\n  </select>\n  </label>\n  <hr />\n  <ChatRoom roomId={roomId} />\n  </>\n  );\n} \nNow that you create the options object inside the Effect, the Effect itself only depends on the roomId string.\nWith this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like roomId doesn‚Äôt change unless you set it to another value. Read more about removing dependencies. Removing unnecessary function dependencies \nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render:\nfunction ChatRoom({ roomId }) {const [message, setMessage] = useState('');function createOptions() { // üö© This function is created from scratch on every re-renderreturn {serverUrl: serverUrl,roomId: roomId};}useEffect(() => {const options = createOptions(); // It's used inside the Effectconst connection = createConnection();connection.connect();return () => connection.disconnect();}, [createOptions]); // üö© As a result, these dependencies are always different on a re-render// ...\nBy itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');  useEffect(() => {\n  function createOptions() {\n  return {\n  serverUrl: serverUrl,\n  roomId: roomId\n  };\n  }  const options = createOptions();\n  const connection = createConnection(options);\n  connection.connect();\n  return () => connection.disconnect();\n  }, [roomId]);  return (\n  <>\n  <h1>Welcome to the {roomId} room!</h1>\n  <input value={message} onChange={e => setMessage(e.target.value)} />\n  </>\n  );\n} export default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n  <>\n  <label>\n  Choose the chat room:{' '}\n  <select\n  value={roomId}\n  onChange={e => setRoomId(e.target.value)}\n  >\n  <option value=\"general\">general</option>\n  <option value=\"travel\">travel</option>\n  <option value=\"music\">music</option>\n  </select>\n  </label>\n  <hr />\n  <ChatRoom roomId={roomId} />\n  </>\n  );\n} \nNow that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike a function which gets re-created, a string like roomId doesn‚Äôt change unless you set it to another value. Read more about removing dependencies. Reading the latest props and state from an Effect \nUnder ConstructionThis section describes an experimental API that has not yet been released in a stable version of React.\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect ‚Äúreacts‚Äù to every change of that value. For most dependencies, that‚Äôs the behavior you want.\nHowever, sometimes you‚Äôll want to read the latest props and state from an Effect without ‚Äúreacting‚Äù to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:\nfunction Page({ url, shoppingCart }) {useEffect(() => {logVisit(url, shoppingCart.length);}, [url, shoppingCart]); // ‚úÖ All dependencies declared// ...}\nWhat if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You can‚Äôt exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you don‚Äôt want a piece of code to ‚Äúreact‚Äù to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it:\nfunction Page({ url, shoppingCart }) {const onVisit = useEffectEvent(visitedUrl => {logVisit(visitedUrl, shoppingCart.length)});useEffect(() => {onVisit(url);}, [url]); // ‚úÖ All dependencies declared// ...}\nEffect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart won‚Äôt re-run your Effect.\nRead more about how Effect Events let you separate reactive and non-reactive code. Displaying different content on the server and the client \nIf your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.\nIn rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it can‚Äôt possibly do that on the server. Here is how you could implement this:\nfunction MyComponent() {const [didMount, setDidMount] = useState(false);useEffect(() => {setDidMount(true);}, []);if (didMount) {// ... return client-only JSX ...}  else {// ... return initial JSX ...}}\nWhile the app is loading, the user will see the initial render output. Then, when it‚Äôs loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects don‚Äôt run on the server, so this is why didMount was false during the initial server render.\nUse this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time‚Äîpotentially, many seconds‚Äîso you don‚Äôt want to make jarring changes to your component‚Äôs appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS. Troubleshooting \nMy Effect runs twice when the component mounts \nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\nThis is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development).\nRead more about how this helps find bugs and how to fix your logic. My Effect runs after every re-render \nFirst, check that you haven‚Äôt forgotten to specify the dependency array:\nuseEffect(() => {// ...}); // üö© No dependency array: re-runs after every render!\nIf you‚Äôve specified the dependency array but your Effect still re-runs in a loop, it‚Äôs because one of your dependencies is different on every re-render.\nYou can debug this problem by manually logging your dependencies to the console:\nuseEffect(() => {// ..}, [serverUrl, roomId]);console.log([serverUrl, roomId]);\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect\nRemoving unnecessary object dependencies\nRemoving unnecessary function dependencies\nReading the latest props and state from an Effect As a last resort (if these methods didn‚Äôt help), wrap its creation with useMemo or useCallback (for functions). My Effect keeps re-running in an infinite cycle \nIf your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state.\nThat state leads to a re-render, which causes the Effect‚Äôs dependencies to change. Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application‚Äôs data flow with it?\nIf there is no external system, consider whether removing the Effect altogether would simplify your logic.\nIf you‚Äôre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component‚Äôs visual output? If you need to keep track of some data that isn‚Äôt used by rendering, a ref (which doesn‚Äôt trigger re-renders) might be more appropriate. Verify your Effect doesn‚Äôt update the state (and trigger re-renders) more than needed.\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it‚Äôs because that state update leads to one of the Effect‚Äôs dependencies changing. Read how to debug dependency changes. My cleanup logic runs even though my component didn‚Äôt unmount \nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.\nIf you have cleanup code without corresponding setup code, it‚Äôs usually a code smell:\nuseEffect(() => {// üî¥ Avoid: Cleanup logic without corresponding setup logicreturn () => {doSomething();};}, []);\nYour cleanup logic should be ‚Äúsymmetrical‚Äù to the setup logic, and should stop or undo whatever setup did:\nuseEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);\nLearn how the Effect lifecycle is different from the component‚Äôs lifecycle. My Effect does something visual, and I see a flicker before it runs \nIf your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldn‚Äôt be needed for the vast majority of Effects. You‚Äôll only need this if it‚Äôs crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it. \n\n,## Webpage #2:\n Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\nThe Effect Hook lets you perform side effects in function components:\nimport React, { useState, useEffect } from 'react';\nfunction Example() {\n  const [count, setCount] = useState(0);  // Similar to componentDidMount and componentDidUpdate:  useEffect(() => {  // Update the document title using the browser API  document.title = `You clicked ${count} times`;  });\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  </div>\n  );\n}\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you‚Äôre used to calling these operations ‚Äúside effects‚Äù (or just ‚Äúeffects‚Äù), you‚Äôve likely performed them in your components before. Tip\nIf you‚Äôre familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined. There are two common kinds of side effects in React components: those that don‚Äôt require cleanup, and those that do. Let‚Äôs look at this distinction in more detail.\nEffects Without Cleanup \nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don‚Äôt require a cleanup. We say that because we can run them and immediately forget about them. Let‚Äôs compare how classes and Hooks let us express such side effects.\nExample Using Classes \nIn React class components, the render method itself shouldn‚Äôt cause side effects. It would be too early ‚Äî we typically want to perform our effects after React has updated the DOM.\nThis is why in React classes, we put side effects into componentDidMount and componentDidUpdate. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\nclass Example extends React.Component {\n  constructor(props) {\n  super(props);\n  this.state = {\n  count: 0\n  };\n  }  componentDidMount() {  document.title = `You clicked ${this.state.count} times`;  }  componentDidUpdate() {  document.title = `You clicked ${this.state.count} times`;  }\n  render() {\n  return (\n  <div>\n  <p>You clicked {this.state.count} times</p>\n  <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n  Click me\n  </button>\n  </div>\n  );\n  }\n}\nNote how we have to duplicate the code between these two lifecycle methods in class.\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render ‚Äî but React class components don‚Äôt have a method like this. We could extract a separate method but we would still have to call it in two places.\nNow let‚Äôs see how we can do the same with the useEffect Hook.\nExample Using Hooks \nWe‚Äôve already seen this example at the top of this page, but let‚Äôs take a closer look at it:\nimport React, { useState, useEffect } from 'react';\nfunction Example() {\n  const [count, setCount] = useState(0);  useEffect(() => {  document.title = `You clicked ${count} times`;  });\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  </div>\n  );\n}\nWhat does useEffect do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we‚Äôll refer to it as our ‚Äúeffect‚Äù), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\nWhy is useEffect called inside a component? Placing useEffect inside the component lets us access the count state variable (or any props) right from the effect. We don‚Äôt need a special API to read it ‚Äî it‚Äôs already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\nDoes useEffect run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of ‚Äúmounting‚Äù and ‚Äúupdating‚Äù, you might find it easier to think that effects happen ‚Äúafter render‚Äù. React guarantees the DOM has been updated by the time it runs the effects.\nDetailed Explanation \nNow that we know more about effects, these lines should make sense:\nfunction Example() {\n  const [count, setCount] = useState(0);  useEffect(() => {\n  document.title = `You clicked ${count} times`;\n  });\n}\nWe declare the count state variable, and then we tell React we need to use an effect. We pass a function to the useEffect Hook. This function we pass is our effect. Inside our effect, we set the document title using the document.title browser API. We can read the latest count inside the effect because it‚Äôs in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\nExperienced JavaScript developers might notice that the function passed to useEffect is going to be different on every render. This is intentional. In fact, this is what lets us read the count value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result ‚Äî each effect ‚Äúbelongs‚Äù to a particular render. We will see more clearly why this is useful later on this page. Tip\nUnlike componentDidMount or componentDidUpdate, effects scheduled with useEffect don‚Äôt block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don‚Äôt need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate useLayoutEffect Hook with an API identical to useEffect. Effects with Cleanup \nEarlier, we looked at how to express side effects that don‚Äôt require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don‚Äôt introduce a memory leak! Let‚Äôs compare how we can do it with classes and with Hooks.\nExample Using Classes \nIn a React class, you would typically set up a subscription in componentDidMount, and clean it up in componentWillUnmount. For example, let‚Äôs say we have a ChatAPI module that lets us subscribe to a friend‚Äôs online status. Here‚Äôs how we might subscribe and display that status using a class:\nclass FriendStatus extends React.Component {\n  constructor(props) {\n  super(props);\n  this.state = { isOnline: null };\n  this.handleStatusChange = this.handleStatusChange.bind(this);\n  }  componentDidMount() {  ChatAPI.subscribeToFriendStatus(  this.props.friend.id,  this.handleStatusChange  );  }  componentWillUnmount() {  ChatAPI.unsubscribeFromFriendStatus(  this.props.friend.id,  this.handleStatusChange  );  }  handleStatusChange(status) {  this.setState({  isOnline: status.isOnline  });  }\n  render() {\n  if (this.state.isOnline === null) {\n  return 'Loading...';\n  }\n  return this.state.isOnline ? 'Online' : 'Offline';\n  }\n}\nNotice how componentDidMount and componentWillUnmount need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect. Note\nEagle-eyed readers may notice that this example also needs a componentDidUpdate method to be fully correct. We‚Äôll ignore this for now but will come back to it in a later section of this page. Example Using Hooks \nLet‚Äôs see how we could write this component with Hooks.\nYou might be thinking that we‚Äôd need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that useEffect is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\nimport React, { useState, useEffect } from 'react'; function FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);  useEffect(() => {  function handleStatusChange(status) {  setIsOnline(status.isOnline);  }  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);  // Specify how to clean up after this effect:  return function cleanup() {  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);  };  });\n  if (isOnline === null) {\n  return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They‚Äôre part of the same effect!\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We‚Äôll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below. Note\nWe don‚Äôt have to return a named function from the effect. We called it cleanup here to clarify its purpose, but you could return an arrow function or call it something different. Recap \nWe‚Äôve learned that useEffect lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n  useEffect(() => {\n  function handleStatusChange(status) {\n  setIsOnline(status.isOnline);\n  }  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n  });\nOther effects might not have a cleanup phase, and don‚Äôt return anything.\n  useEffect(() => {\n  document.title = `You clicked ${count} times`;\n  });\nThe Effect Hook unifies both use cases with a single API. If you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now. Tips for Using Effects \nWe‚Äôll continue this page with an in-depth look at some aspects of useEffect that experienced React users will likely be curious about. Don‚Äôt feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\nTip: Use Multiple Effects to Separate Concerns \nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\nclass FriendStatusWithCounter extends React.Component {\n  constructor(props) {\n  super(props);\n  this.state = { count: 0, isOnline: null };\n  this.handleStatusChange = this.handleStatusChange.bind(this);\n  }  componentDidMount() {\n  document.title = `You clicked ${this.state.count} times`;\n  ChatAPI.subscribeToFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }  componentDidUpdate() {\n  document.title = `You clicked ${this.state.count} times`;\n  }  componentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }  handleStatusChange(status) {\n  this.setState({\n  isOnline: status.isOnline\n  });\n  }\n  // ...\nNote how the logic that sets document.title is split between componentDidMount and componentDidUpdate. The subscription logic is also spread between componentDidMount and componentWillUnmount. And componentDidMount contains code for both tasks.\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {  document.title = `You clicked ${count} times`;\n  });  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {  function handleStatusChange(status) {\n  setIsOnline(status.isOnline);\n  }  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n  });\n  // ...\n}\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\nExplanation: Why Effects Run on Each Update \nIf you‚Äôre used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let‚Äôs look at a practical example to see why this design helps us create components with fewer bugs.\nEarlier on this page, we introduced an example FriendStatus component that displays whether a friend is online or not. Our class reads friend.id from this.props, subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n  componentDidMount() {\n  ChatAPI.subscribeToFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }  componentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }\nBut what happens if the friend prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\nIn a class component, we would need to add componentDidUpdate to handle this case:\n  componentDidMount() {\n  ChatAPI.subscribeToFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }  componentDidUpdate(prevProps) {  // Unsubscribe from the previous friend.id  ChatAPI.unsubscribeFromFriendStatus(  prevProps.friend.id,  this.handleStatusChange  );  // Subscribe to the next friend.id  ChatAPI.subscribeToFriendStatus(  this.props.friend.id,  this.handleStatusChange  );  }\n  componentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n  this.props.friend.id,\n  this.handleStatusChange\n  );\n  }\nForgetting to handle componentDidUpdate properly is a common source of bugs in React applications.\nNow consider the version of this component that uses Hooks:\nfunction FriendStatus(props) {\n  // ...\n  useEffect(() => {\n  // ...\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n  });\nIt doesn‚Äôt suffer from this bug. (But we also didn‚Äôt make any changes to it.)\nThere is no special code for handling updates because useEffect handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n// Mount with { friend: { id: 100 } } props\nChatAPI.subscribeToFriendStatus(100, handleStatusChange);  // Run first effect // Update with { friend: { id: 200 } } props\nChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(200, handleStatusChange);  // Run next effect // Update with { friend: { id: 300 } } props\nChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(300, handleStatusChange);  // Run next effect // Unmount\nChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\nTip: Optimizing Performance by Skipping Effects \nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with prevProps or prevState inside componentDidUpdate:\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) {\n  document.title = `You clicked ${this.state.count} times`;\n  }\n}\nThis requirement is common enough that it is built into the useEffect Hook API. You can tell React to skip applying an effect if certain values haven‚Äôt changed between re-renders. To do so, pass an array as an optional second argument to useEffect:\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // Only re-run the effect if count changes\nIn the example above, we pass [count] as the second argument. What does this mean? If the count is 5, and then our component re-renders with count still equal to 5, React will compare [5] from the previous render and [5] from the next render. Because all items in the array are the same (5 === 5), React would skip the effect. That‚Äôs our optimization.\nWhen we render with count updated to 6, React will compare the items in the [5] array from the previous render to items in the [6] array from the next render. This time, React will re-apply the effect because 5 !== 6. If there are multiple items in the array, React will re-run the effect even if just one of them is different.\nThis also works for effects that have a cleanup phase:\nuseEffect(() => {\n  function handleStatusChange(status) {\n  setIsOnline(status.isOnline);\n  }  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n}, [props.friend.id]); // Only re-subscribe if props.friend.id changes\nIn the future, the second argument might get added automatically by a build-time transformation. Note\nIf you use this optimization, make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect. Otherwise, your code will reference stale values from previous renders. Learn more about how to deal with functions and what to do when the array changes too often.\nIf you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument. This tells React that your effect doesn‚Äôt depend on any values from props or state, so it never needs to re-run. This isn‚Äôt handled as a special case ‚Äî it follows directly from how the dependencies array always works.\nIf you pass an empty array ([]), the props and state inside the effect will always have their initial values. While passing [] as the second argument is closer to the familiar componentDidMount and componentWillUnmount mental model, there are usually better solutions to avoid re-running effects too often. Also, don‚Äôt forget that React defers running useEffect until after the browser has painted, so doing extra work is less of a problem.\nWe recommend using the exhaustive-deps rule as part of our eslint-plugin-react-hooks package. It warns when dependencies are specified incorrectly and suggests a fix. Next Steps \nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You‚Äôve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes ‚Äî and where they don‚Äôt, you might find the additional Hooks helpful.\nWe‚Äôre also starting to see how Hooks solve problems outlined in Motivation. We‚Äôve seen how effect cleanup avoids duplication in componentDidUpdate and componentWillUnmount, brings related code closer together, and helps us avoid bugs. We‚Äôve also seen how we can separate effects by their purpose, which is something we couldn‚Äôt do in classes at all.\nAt this point you might be questioning how Hooks work. How can React know which useState call corresponds to which state variable between re-renders? How does React ‚Äúmatch up‚Äù previous and next effects on every update? On the next page we will learn about the Rules of Hooks ‚Äî they‚Äôre essential to making Hooks work. \n\n,## Webpage #3:\n Nothing found \n\n,## Webpage #4:\n Hi friends !\n  I'm quite new to ReactJS and there are some concepts that I can't figure out. One of them is useEffect...\n  I really dont get the difference between using useEffect and simply calling a function... I looked the documentation but it's not clearing my mind...\n  Someone can explain me useEffect like i was 5 years old ?\n  Thanks !! \n\n,## Webpage #5:\n You wrote a few components with Hooks. Maybe even a small app. You‚Äôre mostly satisfied. You‚Äôre comfortable with the API and picked up a few tricks along the way. You even made some custom Hooks to extract repetitive logic (300 lines gone!) and showed it off to your colleagues. ‚ÄúGreat job‚Äù, they said.\nBut sometimes when you useEffect, the pieces don‚Äôt quite fit together. You have a nagging feeling that you‚Äôre missing something. It seems similar to class lifecycles‚Ä¶ but is it really? You find yourself asking questions like: ü§î How do I replicate componentDidMount with useEffect?\nü§î How do I correctly fetch data inside useEffect? What is []?\nü§î Do I need to specify functions as effect dependencies or not?\nü§î Why do I sometimes get an infinite refetching loop?\nü§î Why do I sometimes get an old state or prop value inside my effect? When I just started using Hooks, I was confused by all of those questions too. Even when writing the initial docs, I didn‚Äôt have a firm grasp on some of the subtleties. I‚Äôve since had a few ‚Äúaha‚Äù moments that I want to share with you. This deep dive will make the answers to these questions look obvious to you.\nTo see the answers, we need to take a step back. The goal of this article isn‚Äôt to give you a list of bullet point recipes. It‚Äôs to help you truly ‚Äúgrok‚Äù useEffect. There won‚Äôt be much to learn. In fact, we‚Äôll spend most of our time unlearning.\nIt‚Äôs only after I stopped looking at the useEffect Hook through the prism of the familiar class lifecycle methods that everything came together for me. ‚ÄúUnlearn what you have learned.‚Äù ‚Äî Yoda \nThis article assumes that you‚Äôre somewhat familiar with useEffect API.\nIt‚Äôs also really long. It‚Äôs like a mini-book. That‚Äôs just my preferred format. But I wrote a TLDR just below if you‚Äôre in a rush or don‚Äôt really care.\nIf you‚Äôre not comfortable with deep dives, you might want to wait until these explanations appear elsewhere. Just like when React came out in 2013, it will take some time for people to recognize a different mental model and teach it. TLDR\nHere‚Äôs a quick TLDR if you don‚Äôt want to read the whole thing. If some parts don‚Äôt make sense, you can scroll down until you find something related.\nFeel free to skip it if you plan to read the whole post. I‚Äôll link to it at the end.\nü§î Question: How do I replicate componentDidMount with useEffect?\nWhile you can useEffect(fn, []), it‚Äôs not an exact equivalent. Unlike componentDidMount, it will capture props and state. So even inside the callbacks, you‚Äôll see the initial props and state. If you want to see ‚Äúlatest‚Äù something, you can write it to a ref. But there‚Äôs usually a simpler way to structure the code so that you don‚Äôt have to. Keep in mind that the mental model for effects is different from componentDidMount and other lifecycles, and trying to find their exact equivalents may confuse you more than help. To get productive, you need to ‚Äúthink in effects‚Äù, and their mental model is closer to implementing synchronization than to responding to lifecycle events.\nü§î Question:  How do I correctly fetch data inside useEffect? What is []?\nThis article is a good primer on data fetching with useEffect. Make sure to read it to the end! It‚Äôs not as long as this one. [] means the effect doesn‚Äôt use any value that participates in React data flow, and is for that reason safe to apply once. It is also a common source of bugs when the value actually is used. You‚Äôll need to learn a few strategies (primarily useReducer and useCallback) that can remove the need for a dependency instead of incorrectly omitting it.\nü§î Question: Do I need to specify functions as effect dependencies or not?\nThe recommendation is to hoist functions that don‚Äôt need props or state outside of your component, and pull the ones that are used only by an effect inside of that effect.  If after that your effect still ends up using functions in the render scope (including function from props), wrap them into useCallback where they‚Äôre defined, and repeat the process. Why does it matter? Functions can ‚Äúsee‚Äù values from props and state ‚Äî so they participate in the data flow. There‚Äôs a more detailed answer in our FAQ.\nü§î Question: Why do I sometimes get an infinite refetching loop?\nThis can happen if you‚Äôre doing data fetching in an effect without the second dependencies argument. Without it, effects run after every render ‚Äî and setting the state will trigger the effects again. An infinite loop may also happen if you specify a value that always changes in the dependency array. You can tell which one by removing them one by one. However, removing a dependency you use (or blindly specifying []) is usually the wrong fix. Instead, fix the problem at its source. For example, functions can cause this problem, and putting them inside effects, hoisting them out, or wrapping them with useCallback helps. To avoid recreating objects, useMemo can serve a similar purpose.\nü§î Why do I sometimes get an old state or prop value inside my effect?\nEffects always ‚Äúsee‚Äù props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref (the linked article explains it at the end). If you think you‚Äôre seeing some props or state from an old render but don‚Äôt expect it, you probably missed some dependencies. Try using the lint rule to train yourself to see them. A few days, and it‚Äôll be like a second nature to you. See also this answer in our FAQ. I hope this TLDR was helpful! Otherwise, let‚Äôs go. Each Render Has Its Own Props and State\nBefore we can talk about effects, we need to talk about rendering.\nHere‚Äôs a counter. Look at the highlighted line closely:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  </div>\n  );\n}\nWhat does it mean? Does count somehow ‚Äúwatch‚Äù changes to our state and update automatically? That might be a useful first intuition when you learn React but it‚Äôs not an accurate mental model.\nIn this example, count is just a number. It‚Äôs not a magic ‚Äúdata binding‚Äù, a ‚Äúwatcher‚Äù, a ‚Äúproxy‚Äù, or anything else. It‚Äôs a good old number like this one:\nconst count = 42;\n// ...\n<p>You clicked {count} times</p>\n// ...\nThe first time our component renders, the count variable we get from useState() is 0. When we call setCount(1), React calls our component again. This time, count will be 1. And so on:\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\nWhenever we update the state, React calls our component. Each render result ‚Äúsees‚Äù its own counter state value which is a constant inside our function.\nSo this line doesn‚Äôt do any special data binding:\n<p>You clicked {count} times</p>\nIt only embeds a number value into the render output. That number is provided by React. When we setCount, React calls our component again with a different count value. Then React updates the DOM to match our latest render output.\nThe key takeaway is that the count constant inside any particular render doesn‚Äôt change over time. It‚Äôs our component that‚Äôs called again ‚Äî and each render ‚Äúsees‚Äù its own count value that‚Äôs isolated between renders.\n(For an in-depth overview of this process, check out my post React as a UI Runtime.)\nEach Render Has Its Own Event Handlers\nSo far so good. What about event handlers?\nLook at this example. It shows an alert with the count after three seconds:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + count);\n  }, 3000);\n  }\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  <button onClick={handleAlertClick}>\n  Show alert\n  </button>\n  </div>\n  );\n}\nLet‚Äôs say I do this sequence of steps: Increment the counter to 3\nPress ‚ÄúShow alert‚Äù\nIncrement it to 5 before the timeout fires \nWhat do you expect the alert to show? Will it show 5 ‚Äî which is the counter state at the time of the alert? Or will it show 3 ‚Äî the state when I clicked? spoilers ahead Go ahead and try it yourself!\nIf the behavior doesn‚Äôt quite make sense to you, imagine a more practical example: a chat app with the current recipient ID in the state, and a Send button. This article explores the reasons in depth but the correct answer is 3.\nThe alert will ‚Äúcapture‚Äù the state at the time I clicked the button.\n(There are ways to implement the other behavior too but I‚Äôll be focusing on the default case for now. When building a mental model, it‚Äôs important that we distinguish the ‚Äúpath of least resistance‚Äù from the opt-in escape hatches.) But how does it work?\nWe‚Äôve discussed that the count value is constant for every particular call to our function. It‚Äôs worth emphasizing this ‚Äî our function gets called many times (once per each render), but every one of those times the count value inside of it is constant and set to a particular value (state for that render).\nThis is not specific to React ‚Äî regular functions work in a similar way:\nfunction sayHi(person) {\n  const name = person.name;\n  setTimeout(() => {\n  alert('Hello, ' + name);\n  }, 3000);\n}\nlet someone = {name: 'Dan'};\nsayHi(someone);\nsomeone = {name: 'Yuzhi'};\nsayHi(someone);\nsomeone = {name: 'Dominic'};\nsayHi(someone);\nIn this example, the outer someone variable is reassigned several times. (Just like somewhere in React, the current component state can change.) However, inside sayHi, there is a local name constant that is associated with a person from a particular call. That constant is local, so it‚Äôs isolated between the calls! As a result, when the timeouts fire, each alert ‚Äúremembers‚Äù its own name.\nThis explains how our event handler captures the count at the time of the click. If we apply the same substitution principle, each render ‚Äúsees‚Äù its own count:\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + count);\n  }, 3000);\n  }\n  // ...\n}\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + count);\n  }, 3000);\n  }\n  // ...\n}\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + count);\n  }, 3000);\n  }\n  // ...\n}\nSo effectively, each render returns its own ‚Äúversion‚Äù of handleAlertClick. Each of those versions ‚Äúremembers‚Äù its own count:\n// During first render\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + 0);\n  }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 0 inside\n  // ...\n}\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + 1);\n  }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 1 inside\n  // ...\n}\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n  setTimeout(() => {\n  alert('You clicked on: ' + 2);\n  }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 2 inside\n  // ...\n}\nThis is why in this demo event handlers ‚Äúbelong‚Äù to a particular render, and when you click, it keeps using the counter state from that render.\nInside any particular render, props and state forever stay the same. But if props and state are isolated between renders, so are any values using them (including the event handlers). They also ‚Äúbelong‚Äù to a particular render. So even async functions inside an event handler will ‚Äúsee‚Äù the same count value.\nSide note: I inlined concrete count values right into handleAlertClick functions above. This mental substitution is safe because count can‚Äôt possibly change within a particular render. It‚Äôs declared as a const and is a number. It would be safe to think the same way about other values like objects too, but only if we agree to avoid mutating state. Calling setSomething(newObj) with a newly created object instead of mutating it is fine because state belonging to previous renders is intact.\nEach Render Has Its Own Effects\nThis was supposed to be a post about effects but we still haven‚Äôt talked about effects yet! We‚Äôll rectify this now. Turns out, effects aren‚Äôt really any different.\nLet‚Äôs go back to an example from the docs:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n  document.title = `You clicked ${count} times`;\n  });\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  </div>\n  );\n}\nHere‚Äôs a question for you: how does the effect read the latest count state?\nMaybe, there‚Äôs some kind of ‚Äúdata binding‚Äù or ‚Äúwatching‚Äù that makes count update live inside the effect function? Maybe count is a mutable variable that React sets inside our component so that our effect always sees the latest value?\nNope.\nWe already know that count is constant within a particular component render. Event handlers ‚Äúsee‚Äù the count state from the render that they ‚Äúbelong‚Äù to because count is a variable in their scope. The same is true for effects!\nIt‚Äôs not the count variable that somehow changes inside an ‚Äúunchanging‚Äù effect. It‚Äôs the effect function itself that‚Äôs different on every render.\nEach version ‚Äúsees‚Äù the count value from the render that it ‚Äúbelongs‚Äù to:\n// During first render\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect function from first render\n  () => {\n  document.title = `You clicked ${0} times`;\n  }\n  );\n  // ...\n}\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect function from second render\n  () => {\n  document.title = `You clicked ${1} times`;\n  }\n  );\n  // ...\n}\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect function from third render\n  () => {\n  document.title = `You clicked ${2} times`;\n  }\n  );\n  // ..\n}\nReact remembers the effect function you provided, and runs it after flushing changes to the DOM and letting the browser paint the screen.\nSo even if we speak of a single conceptual effect here (updating the document title), it is represented by a different function on every render ‚Äî and each effect function ‚Äúsees‚Äù props and state from the particular render it ‚Äúbelongs‚Äù to.\nConceptually, you can imagine effects are a part of the render result.\nStrictly saying, they‚Äôre not (in order to allow Hook composition without clumsy syntax or runtime overhead). But in the mental model we‚Äôre building up, effect functions belong to a particular render in the same way that event handlers do. To make sure we have a solid understanding, let‚Äôs recap our first render: React: Give me the UI when the state is 0.\nYour component: Here‚Äôs the render result:\n<p>You clicked 0 times</p>.\nAlso remember to run this effect after you‚Äôre done: () => { document.title = 'You clicked 0 times' }. \nReact: Sure. Updating the UI. Hey browser, I‚Äôm adding some stuff to the DOM.\nBrowser: Cool, I painted it to the screen.\nReact: OK, now I‚Äôm going to run the effect you gave me. Running () => { document.title = 'You clicked 0 times' }. \nNow let‚Äôs recap what happens after we click: Your component: Hey React, set my state to 1.\nReact: Give me the UI for when the state is 1.\nYour component: Here‚Äôs the render result:\n<p>You clicked 1 times</p>.\nAlso remember to run this effect after you‚Äôre done: () => { document.title = 'You clicked 1 times' }. \nReact: Sure. Updating the UI. Hey browser, I‚Äôve changed the DOM.\nBrowser: Cool, I painted your changes to the screen.\nReact: OK, now I‚Äôll run the effect that belongs to the render I just did. Running () => { document.title = 'You clicked 1 times' }. \nEach Render Has Its Own‚Ä¶ Everything\nWe know now that effects run after every render, are conceptually a part of the component output, and ‚Äúsee‚Äù the props and state from that particular render.\nLet‚Äôs try a thought experiment. Consider this code:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n  setTimeout(() => {\n  console.log(`You clicked ${count} times`);\n  }, 3000);\n  });\n  return (\n  <div>\n  <p>You clicked {count} times</p>\n  <button onClick={() => setCount(count + 1)}>\n  Click me\n  </button>\n  </div>\n  );\n}\nIf I click several times with a small delay, what is the log going to look like? spoilers ahead You might think this is a gotcha and the end result is unintuitive. It‚Äôs not! We‚Äôre going to see a sequence of logs ‚Äî each one belonging to a particular render and thus with its own count value. You can try it yourself: You may think: ‚ÄúOf course that‚Äôs how it works! How else could it work?‚Äù\nWell, that‚Äôs not how this.state works in classes. It‚Äôs easy to make the mistake of thinking that this class implementation is equivalent:\n  componentDidUpdate() {\n  setTimeout(() => {\n  console.log(`You clicked ${this.state.count} times`);\n  }, 3000);\n  }\nHowever, this.state.count always points at the latest count rather than the one belonging to a particular render. So you‚Äôll see 5 logged each time instead: I think it‚Äôs ironic that Hooks rely so much on JavaScript closures, and yet it‚Äôs the class implementation that suffers from the canonical wrong-value-in-a-timeout confusion that‚Äôs often associated with closures. This is because the actual source of the confusion in this example is the mutation (React mutates this.state in classes to point to the latest state) and not closures themselves.\nClosures are great when the values you close over never change. That makes them easy to think about because you‚Äôre essentially referring to constants. And as we discussed, props and state never change within a particular render. By the way, we can fix the class version‚Ä¶ by using a closure.\nSwimming Against the Tide\nAt this point it‚Äôs important that we call it out explicitly: every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.\nSo these two examples are equivalent:\nfunction Example(props) {\n  useEffect(() => {\n  setTimeout(() => {\n  console.log(props.counter);\n  }, 1000);\n  });\n  // ...\n}\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n  setTimeout(() => {\n  console.log(counter);\n  }, 1000);\n  });\n  // ...\n}\nIt doesn‚Äôt matter whether you read from props or state ‚Äúearly‚Äù inside of your component. They‚Äôre not going to change! Inside the scope of a single render, props and state stay the same. (Destructuring props makes this more obvious.)\nOf course, sometimes you want to read the latest rather than captured value inside some callback defined in an effect. The easiest way to do it is by using refs, as described in the last section of this article.\nBe aware that when you want to read the future props or state from a function in a past render, you‚Äôre swimming against the tide. It‚Äôs not wrong (and in some cases necessary) but it might look less ‚Äúclean‚Äù to break out of the paradigm. This is an intentional consequence because it helps highlight which code is fragile and depends on timing. In classes, it‚Äôs less obvious when this happens.\nHere‚Äôs a version of our counter example that replicates the class behavior:\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n  useEffect(() => {\n  // Set the mutable latest value\n  latestCount.current = count;\n  setTimeout(() => {\n  // Read the mutable latest value\n  console.log(`You clicked ${latestCount.current} times`);\n  }, 3000);\n  });\n  // ... It might seem quirky to mutate something in React. However, this is exactly how React itself reassigns this.state in classes. Unlike with captured props and state, you don‚Äôt have any guarantees that reading latestCount.current would give you the same value in any particular callback. By definition, you can mutate it any time. This is why it‚Äôs not a default, and you have to opt into that.\nSo What About Cleanup?\nAs the docs explain, some effects might have a cleanup phase. Essentially, its purpose is to ‚Äúundo‚Äù an effect for cases like subscriptions.\nConsider this code:\n  useEffect(() => {\n  ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n  };\n  });\nSay props is {id: 10} on the first render, and {id: 20} on the second render. You might think that something like this happens: React cleans up the effect for {id: 10}.\nReact renders UI for {id: 20}.\nReact runs the effect for {id: 20}. (This is not quite the case.)\nWith this mental model, you might think the cleanup ‚Äúsees‚Äù the old props because it runs before we re-render, and then the new effect ‚Äúsees‚Äù the new props because it runs after the re-render. That‚Äôs the mental model lifted directly from the class lifecycles, and it‚Äôs not accurate here. Let‚Äôs see why.\nReact only runs the effects after letting the browser paint. This makes your app faster as most effects don‚Äôt need to block screen updates. Effect cleanup is also delayed. The previous effect is cleaned up after the re-render with new props: React renders UI for {id: 20}.\nThe browser paints. We see the UI for {id: 20} on the screen.\nReact cleans up the effect for {id: 10}.\nReact runs the effect for {id: 20}. You might be wondering: but how can the cleanup of the previous effect still ‚Äúsee‚Äù the old {id: 10} props if it runs after the props change to {id: 20}?\nWe‚Äôve been here before‚Ä¶ ü§î Quoting the previous section: Every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it. Now the answer is clear! The effect cleanup doesn‚Äôt read the ‚Äúlatest‚Äù props, whatever that means. It reads props that belong to the render it‚Äôs defined in:\n// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(\n  // Effect from first render\n  () => {\n  ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n  // Cleanup for effect from first render\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);\n  };\n  }\n  );\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(\n  // Effect from second render\n  () => {\n  ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n  // Cleanup for effect from second render\n  return () => {\n  ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);\n  };\n  }\n  );\n  // ...\n}\nKingdoms will rise and turn into ashes, the Sun will shed its outer layers to be a white dwarf, and the last civilization will end. But nothing will make the props ‚Äúseen‚Äù by the first render effect‚Äôs cleanup anything other than {id: 10}.\nThat‚Äôs what allows React to deal with effects right after painting ‚Äî and make your apps faster by default. The old props are still there if our code needs them.\nSynchronization, Not Lifecycle\nOne of my favorite things about React is that it unifies describing the initial render result and the updates. This reduces the entropy of your program.\nSay my component looks like this:\nfunction Greeting({ name }) {\n  return (\n  <h1 className=\"Greeting\">\n  Hello, {name}\n  </h1>\n  );\n}\nIt doesn‚Äôt matter if I render <Greeting name=\"Dan\" /> and later <Greeting name=\"Yuzhi\" />, or if I just render <Greeting name=\"Yuzhi\" />. In the end, we will see ‚ÄúHello, Yuzhi‚Äù in both cases.\nPeople say: ‚ÄúIt‚Äôs all about the journey, not the destination‚Äù. With React, it‚Äôs the opposite. It‚Äôs all about the destination, not the journey. That‚Äôs the difference between $.addClass and $.removeClass calls in jQuery code (our ‚Äújourney‚Äù) and specifying what the CSS class should be in React code (our ‚Äúdestination‚Äù).\nReact synchronizes the DOM according to our current props and state. There is no distinction between a ‚Äúmount‚Äù or an ‚Äúupdate‚Äù when rendering.\nYou should think of effects in a similar way. useEffect lets you synchronize things outside of the React tree according to our props and state.\nfunction Greeting({ name }) {\n  useEffect(() => {\n  document.title = 'Hello, ' + name;\n  });\n  return (\n  <h1 className=\"Greeting\">\n  Hello, {name}\n  </h1>\n  );\n}\nThis is subtly different from the familiar mount/update/unmount mental model. It is important really to internalize this. If you‚Äôre trying to write an effect that behaves differently depending on whether the component renders for the first time or not, you‚Äôre swimming against the tide! We‚Äôre failing at synchronizing if our result depends on the ‚Äújourney‚Äù rather than the ‚Äúdestination‚Äù.\nIt shouldn‚Äôt matter whether we rendered with props A, B, and C, or if we rendered with C immediately. While there may be some temporary differences (e.g. while we‚Äôre fetching data), eventually the end result should be the same.\nStill, of course running all effects on every render might not be efficient. (And in some cases, it would lead to infinite loops.)\nSo how can we fix this?\nTeaching React to Diff Your Effects\nWe‚Äôve already learned that lesson with the DOM itself. Instead of touching it on every re-render, React only updates the parts of the DOM that actually change.\nWhen you‚Äôre updating\n<h1 className=\"Greeting\">\n  Hello, Dan\n</h1>\nto\n<h1 className=\"Greeting\">\n  Hello, Yuzhi\n</h1>\nReact sees two objects:\nconst oldProps = {className: 'Greeting', children: 'Hello, Dan'};\nconst newProps = {className: 'Greeting', children: 'Hello, Yuzhi'};\nIt goes over each of their props and determine that children have changed and need a DOM update, but className did not. So it can just do:\ndomNode.innerText = 'Hello, Yuzhi';\n// No need to touch domNode.className\nCould we do something like this with effects too? It would be nice to avoid re-running them when applying the effect is unnecessary.\nFor example, maybe our component re-renders because of a state change:\nfunction Greeting({ name }) {\n  const [counter, setCounter] = useState(0);\n  useEffect(() => {\n  document.title = 'Hello, ' + name;\n  });\n  return (\n  <h1 className=\"Greeting\">\n  Hello, {name}\n  <button onClick={() => setCounter(count + 1)}>\n  Increment\n  </button>\n  </h1>\n  );\n}\nBut our effect doesn‚Äôt use the counter state. Our effect synchronizes the document.title with the name prop, but the name prop is the same. Re-assigning document.title on every counter change seems non-ideal.\nOK, so can React just‚Ä¶ diff effects?\nlet oldEffect = () => { document.title = 'Hello, Dan'; };\nlet newEffect = () => { document.title = 'Hello, Dan'; };\n// Can React see these functions do the same thing?\nNot really. React can‚Äôt guess what the function does without calling it. (The source doesn‚Äôt really contain specific values, it just closes over the name prop.)\nThis is why if you want to avoid re-running effects unnecessarily, you can provide a dependency array (also known as ‚Äúdeps‚Äù) argument to useEffect:\n  useEffect(() => {\n  document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\nIt‚Äôs like if we told React: ‚ÄúHey, I know you can‚Äôt see inside this function, but I promise it only uses name and nothing else from the render scope.‚Äù\nIf each of these values is the same between the current and the previous time this effect ran, there‚Äôs nothing to synchronize so React can skip the effect:\nconst oldEffect = () => { document.title = 'Hello, Dan'; };\nconst oldDeps = ['Dan'];\nconst newEffect = () => { document.title = 'Hello, Dan'; };\nconst newDeps = ['Dan'];\n// React can't peek inside of functions, but it can compare deps.\n// Since all deps are the same, it doesn‚Äôt need to run the new effect.\nIf even one of the values in the dependency array is different between renders, we know running the effect can‚Äôt be skipped. Synchronize all the things!\nDon‚Äôt Lie to React About Dependencies\nLying to React about dependencies has bad consequences. Intuitively, this makes sense, but I‚Äôve seen pretty much everyone who tries useEffect with a mental model from classes try to cheat the rules. (And I did that too at first!)\nfunction SearchResults() {\n  async function fetchData() {\n  // ...\n  }\n  useEffect(() => {\n  fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n  // ...\n}\n(The Hooks FAQ explains what to do instead. We‚Äôll come back to this example below.)\n‚ÄúBut I only want to run it on mount!‚Äù, you‚Äôll say. For now, remember: if you specify deps, all values from inside your component that are used by the effect must be there. Including props, state, functions ‚Äî anything in your component.\nSometimes when you do that, it causes a problem. For example, maybe you see an infinite refetching loop, or a socket is recreated too often. The solution to that problem is not to remove a dependency. We‚Äôll look at the solutions soon.\nBut before we jump to solutions, let‚Äôs understand the problem better.\nWhat Happens When Dependencies Lie\nIf deps contain every value used by the effect, React knows when to re-run it:\n  useEffect(() => {\n  document.title = 'Hello, ' + name;\n  }, [name]); (Dependencies are different, so we re-run the effect.)\nBut if we specified [] for this effect, the new effect function wouldn‚Äôt run:\n  useEffect(() => {\n  document.title = 'Hello, ' + name;\n  }, []); // Wrong: name is missing in deps (Dependencies are equal, so we skip the effect.)\nIn this case the problem might seem obvious. But the intuition can fool you in other cases where a class solution ‚Äújumps out‚Äù from your memory.\nFor example, let‚Äôs say we‚Äôre writing a counter that increments every second. With a class, our intuition is: ‚ÄúSet up the interval once and destroy it once‚Äù. Here‚Äôs an example of how we can do it. When we mentally translate this code to useEffect, we instinctively add [] to the deps. ‚ÄúI want it to run once‚Äù, right?\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n  const id = setInterval(() => {\n  setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n  }, []);\n  return <h1>{count}</h1>;\n}\nHowever, this example only increments once. Oops.\nIf your mental model is ‚Äúdependencies let me specify when I want to re-trigger the effect‚Äù, this example might give you an existential crisis. You want to trigger it once because it‚Äôs an interval ‚Äî so why is it causing issues?\nHowever, this makes sense if you know that dependencies are our hint to React about everything that the effect uses from the render scope. It uses count but we lied that it doesn‚Äôt with []. It‚Äôs only a matter of time before this bites us!\nIn the first render, count is 0. Therefore, setCount(count + 1) in the first render‚Äôs effect means setCount(0 + 1). Since we never re-run the effect because of [] deps, it will keep calling setCount(0 + 1) every second:\n// First render, state is 0\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect from first render\n  () => {\n  const id = setInterval(() => {\n  setCount(0 + 1); // Always setCount(1)\n  }, 1000);\n  return () => clearInterval(id);\n  },\n  [] // Never re-runs\n  );\n  // ...\n}\n// Every next render, state is 1\nfunction Counter() {\n  // ...\n  useEffect(\n  // This effect is always ignored because\n  // we lied to React about empty deps.\n  () => {\n  const id = setInterval(() => {\n  setCount(1 + 1);\n  }, 1000);\n  return () => clearInterval(id);\n  },\n  []\n  );\n  // ...\n}\nWe lied to React by saying our effect doesn‚Äôt depend on a value from inside our component, when in fact it does!\nOur effect uses count ‚Äî a value inside the component (but outside the effect):\n  const count = // ...\n  useEffect(() => {\n  const id = setInterval(() => {\n  setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n  }, []);\nTherefore, specifying [] as a dependency will create a bug. React will compare the dependencies, and skip updating this effect: (Dependencies are equal, so we skip the effect.)\nIssues like this are difficult to think about. Therefore, I encourage you to adopt it as a hard rule to always be honest about the effect dependencies, and specify them all. (We provide a lint rule if you want to enforce this on your team.)\nTwo Ways to Be Honest About Dependencies\nThere are two strategies to be honest about dependencies. You should generally start with the first one, and then apply the second one if needed.\nThe first strategy is to fix the dependency array to include all the values inside the component that are used inside the effect. Let‚Äôs include count as a dep:\nuseEffect(() => {\n  const id = setInterval(() => {\n  setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\nThis makes the dependency array correct. It may not be ideal but that‚Äôs the first issue we needed to fix. Now a change to count will re-run the effect, with each next interval referencing count from its render in setCount(count + 1):\n// First render, state is 0\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect from first render\n  () => {\n  const id = setInterval(() => {\n  setCount(0 + 1); // setCount(count + 1)\n  }, 1000);\n  return () => clearInterval(id);\n  },\n  [0] // [count]\n  );\n  // ...\n}\n// Second render, state is 1\nfunction Counter() {\n  // ...\n  useEffect(\n  // Effect from second render\n  () => {\n  const id = setInterval(() => {\n  setCount(1 + 1); // setCount(count + 1)\n  }, 1000);\n  return () => clearInterval(id);\n  },\n  [1] // [count]\n  );\n  // ...\n}\nThat would fix the problem but our interval would be cleared and set again whenever the count changes. That may be undesirable: (Dependencies are different, so we re-run the effect.) The second strategy is to change our effect code so that it wouldn‚Äôt need a value that changes more often than we want. We don‚Äôt want to lie about the dependencies ‚Äî we just want to change our effect to have fewer of them.\nLet‚Äôs look at a few common techniques for removing dependencies. Making Effects Self-Sufficient\nWe want to get rid of the count dependency in our effect.\n  useEffect(() => {\n  const id = setInterval(() => {\n  setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n  }, [count]);\nTo do this, we need to ask ourselves: what are we using count for? It seems like we only use it for the setCount call. In that case, we don‚Äôt actually need count in the scope at all. When we want to update state based on the previous state, we can use the functional updater form of setState:\n  useEffect(() => {\n  const id = setInterval(() => {\n  setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n  }, []);\nI like to think of these cases as ‚Äúfalse dependencies‚Äù. Yes, count was a necessary dependency because we wrote setCount(count + 1) inside the effect. However, we only truly needed count to transform it into count + 1 and ‚Äúsend it back‚Äù to React. But React already knows the current count. All we needed to tell React is to increment the state ‚Äî whatever it is right now.\nThat‚Äôs exactly what setCount(c => c + 1) does. You can think of it as ‚Äúsending an instruction‚Äù to React about how the state should change. This ‚Äúupdater form‚Äù also helps in other cases, like when you batch multiple updates.\nNote that we actually did the work to remove the dependency. We didn‚Äôt cheat. Our effect doesn‚Äôt read the counter value from the render scope anymore: (Dependencies are equal, so we skip the effect.)\nYou can try it here.\nEven though this effect only runs once, the interval callback that belongs to the first render is perfectly capable of sending the c => c + 1 update instruction every time the interval fires. It doesn‚Äôt need to know the current counter state anymore. React already knows it.\nFunctional Updates and Google Docs\nRemember how we talked about synchronization being the mental model for effects? An interesting aspect of synchronization is that you often want to keep the ‚Äúmessages‚Äù between the systems untangled from their state. For example, editing a document in Google Docs doesn‚Äôt actually send the whole page to the server. That would be very inefficient. Instead, it sends a representation of what the user tried to do.\nWhile our use case is different, a similar philosophy applies to effects. It helps to send only the minimal necessary information from inside the effects into a component. The updater form like setCount(c => c + 1) conveys strictly less information than setCount(count + 1) because it isn‚Äôt ‚Äútainted‚Äù by the current count. It only expresses the action (‚Äúincrementing‚Äù). Thinking in React involves finding the minimal state. This is the same principle, but for updates.\nEncoding the intent (rather than the result) is similar to how Google Docs solves collaborative editing. While this is stretching the analogy, functional updates serve a similar role in React. They ensure updates from multiple sources (event handlers, effect subscriptions, etc) can be correctly applied in a batch and in a predictable way.\nHowever, even setCount(c => c + 1) isn‚Äôt that great. It looks a bit weird and it‚Äôs very limited in what it can do. For example, if we had two state variables whose values depend on each other, or if we needed to calculate the next state based on a prop, it wouldn‚Äôt help us. Luckily, setCount(c => c + 1) has a more powerful sister pattern. Its name is useReducer.\nDecoupling Updates from Actions\nLet‚Äôs modify the previous example to have two state variables: count and step. Our interval will increment the count by the value of the step input:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n  useEffect(() => {\n  const id = setInterval(() => {\n  setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n  }, [step]);\n  return (\n  <>\n  <h1>{count}</h1>\n  <input value={step} onChange={e => setStep(Number(e.target.value))} />\n  </>\n  );\n}\n(Here‚Äôs a demo.)\nNote that we‚Äôre not cheating. Since I started using step inside the effect, I added it to the dependencies. And that‚Äôs why the code runs correctly.\nThe current behavior in this example is that changing the step restarts the interval ‚Äî because it‚Äôs one of the dependencies. And in many cases, that is exactly what you want! There‚Äôs nothing wrong with tearing down an effect and setting it up anew, and we shouldn‚Äôt avoid that unless we have a good reason.\nHowever, let‚Äôs say we want the interval clock to not reset on changes to the step. How do we remove the step dependency from our effect?\nWhen setting a state variable depends on the current value of another state variable, you might want to try replacing them both with useReducer.\nWhen you find yourself writing setSomething(something => ...), it‚Äôs a good time to consider using a reducer instead. A reducer lets you decouple expressing the ‚Äúactions‚Äù that happened in your component from how the state updates in response to them.\nLet‚Äôs trade the step dependency for a dispatch dependency in our effect:\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() => {\n  const id = setInterval(() => {\n  dispatch({ type: 'tick' }); // Instead of setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n(See the demo.)\nYou might ask me: ‚ÄúHow is this any better?‚Äù The answer is that React guarantees the dispatch function to be constant throughout the component lifetime. So the example above doesn‚Äôt ever need to resubscribe the interval.\nWe solved our problem!\n(You may omit dispatch, setState, and useRef container values from the deps because React guarantees them to be static. But it also doesn‚Äôt hurt to specify them.)\nInstead of reading the state inside an effect, it dispatches an action that encodes the information about what happened. This allows our effect to stay decoupled from the step state. Our effect doesn‚Äôt care how we update the state, it just tells us about what happened. And the reducer centralizes the update logic:\nconst initialState = {\n  count: 0,\n  step: 1,\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === 'tick') {\n  return { count: count + step, step };\n  } else if (action.type === 'step') {\n  return { count, step: action.step };\n  } else {\n  throw new Error();\n  }\n}\n(Here‚Äôs a demo if you missed it earlier).\nWhy useReducer Is the Cheat Mode of Hooks\nWe‚Äôve seen how to remove dependencies when an effect needs to set state based on previous state, or on another state variable. But what if we need props to calculate the next state? For example, maybe our API is <Counter step={1} />. Surely, in this case we can‚Äôt avoid specifying props.step as a dependency?\nIn fact, we can! We can put the reducer itself inside our component to read props:\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n  if (action.type === 'tick') {\n  return state + step;\n  } else {\n  throw new Error();\n  }\n  }\n  useEffect(() => {\n  const id = setInterval(() => {\n  dispatch({ type: 'tick' });\n  }, 1000);\n  return () => clearInterval(id);\n  }, [dispatch]);\n  return <h1>{count}</h1>;\n}\nThis pattern disables a few optimizations so try not to use it everywhere, but you can totally access props from a reducer if you need to. (Here‚Äôs a demo.)\nEven in that case, dispatch identity is still guaranteed to be stable between re-renders. So you may omit it from the effect deps if you want. It‚Äôs not going to cause the effect to re-run.\nYou may be wondering: how can this possibly work? How can the reducer ‚Äúknow‚Äù props when called from inside an effect that belongs to another render? The answer is that when you dispatch, React just remembers the action ‚Äî but it will call your reducer during the next render. At that point the fresh props will be in scope, and you won‚Äôt be inside an effect.\nThis is why I like to think of useReducer as the ‚Äúcheat mode‚Äù of Hooks. It lets me decouple the update logic from describing what happened. This, in turn, helps me remove unnecessary dependencies from my effects and avoid re-running them more often than necessary.\nMoving Functions Inside Effects\nA common mistake is to think functions shouldn‚Äôt be dependencies. For example, this seems like it could work:\nfunction SearchResults() {\n  const [data, setData] = useState({ hits: [] });\n  async function fetchData() {\n  const result = await axios(\n  'https://hn.algolia.com/api/v1/search?query=react',\n  );\n  setData(result.data);\n  }\n  useEffect(() => {\n  fetchData();\n  }, []); // Is this okay?\n  // ...\n(This example is adapted from a great article by Robin Wieruch ‚Äî check it out!)\nAnd to be clear, this code does work. But the problem with simply omitting local functions is that it gets pretty hard to tell whether we‚Äôre handling all cases as the component grows!\nImagine our code was split like this and each function was five times larger:\nfunction SearchResults() {\n  // Imagine this function is long\n  function getFetchUrl() {\n  return 'https://hn.algolia.com/api/v1/search?query=react';\n  }\n  // Imagine this function is also long\n  async function fetchData() {\n  const result = await axios(getFetchUrl());\n  setData(result.data);\n  }\n  useEffect(() => {\n  fetchData();\n  }, []);\n  // ...\n}\nNow let‚Äôs say we later use some state or prop in one of these functions:\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n  // Imagine this function is also long\n  function getFetchUrl() {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n  // Imagine this function is also long\n  async function fetchData() {\n  const result = await axios(getFetchUrl());\n  setData(result.data);\n  }\n  useEffect(() => {\n  fetchData();\n  }, []);\n  // ...\n}\nIf we forget to update the deps of any effects that call these functions (possibly, through other functions!), our effects will fail to synchronize changes from our props and state. This doesn‚Äôt sound great.\nLuckily, there is an easy solution to this problem. If you only use some functions inside an effect, move them directly into that effect:\nfunction SearchResults() {\n  // ...\n  useEffect(() => {\n  // We moved these functions inside!\n  function getFetchUrl() {\n  return 'https://hn.algolia.com/api/v1/search?query=react';\n  }\n  async function fetchData() {\n  const result = await axios(getFetchUrl());\n  setData(result.data);\n  }\n  fetchData();\n  }, []); // ‚úÖ Deps are OK\n  // ...\n}\n(Here‚Äôs a demo.)\nSo what is the benefit? We no longer have to think about the ‚Äútransitive dependencies‚Äù. Our dependencies array isn‚Äôt lying anymore: we truly aren‚Äôt using anything from the outer scope of the component in our effect.\nIf we later edit getFetchUrl to use the query state, we‚Äôre much more likely to notice that we‚Äôre editing it inside an effect ‚Äî and therefore, we need to add query to the effect dependencies:\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n  useEffect(() => {\n  function getFetchUrl() {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n  async function fetchData() {\n  const result = await axios(getFetchUrl());\n  setData(result.data);\n  }\n  fetchData();\n  }, [query]); // ‚úÖ Deps are OK\n  // ...\n}\n(Here‚Äôs a demo.)\nBy adding this dependency, we‚Äôre not just ‚Äúappeasing React‚Äù. It makes sense to refetch the data when the query changes. The design of useEffect forces you to notice the change in our data flow and choose how our effects should synchronize it ‚Äî instead of ignoring it until our product users hit a bug.\nThanks to the exhaustive-deps lint rule from the eslint-plugin-react-hooks plugin, you can analyze the effects as you type in your editor and receive suggestions about which dependencies are missing. In other words, a machine can tell you which data flow changes aren‚Äôt handled correctly by a component. Pretty sweet.\nBut I Can‚Äôt Put This Function Inside an Effect\nSometimes you might not want to move a function inside an effect. For example, several effects in the same component may call the same function, and you don‚Äôt want to copy and paste its logic. Or maybe it‚Äôs a prop.\nShould you skip a function like this in the effect dependencies? I think not. Again, effects shouldn‚Äôt lie about their dependencies. There are usually better solutions. A common misconception is that ‚Äúa function would never change‚Äù. But as we learned throughout this article, this couldn‚Äôt be further from truth. Indeed, a function defined inside a component changes on every render!\nThat by itself presents a problem. Say two effects call getFetchUrl:\nfunction SearchResults() {\n  function getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n  useEffect(() => {\n  const url = getFetchUrl('react');\n  // ... Fetch data and do something ...\n  }, []); // üî¥ Missing dep: getFetchUrl\n  useEffect(() => {\n  const url = getFetchUrl('redux');\n  // ... Fetch data and do something ...\n  }, []); // üî¥ Missing dep: getFetchUrl\n  // ...\n}\nIn that case you might not want to move getFetchUrl inside either of the effects since you wouldn‚Äôt be able to share the logic.\nOn the other hand, if you‚Äôre ‚Äúhonest‚Äù about the effect dependencies, you may run into a problem. Since both our effects depend on getFetchUrl (which is different on every render), our dependency arrays are useless:\nfunction SearchResults() {\n  // üî¥ Re-triggers all effects on every render\n  function getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n  useEffect(() => {\n  const url = getFetchUrl('react');\n  // ... Fetch data and do something ...\n  }, [getFetchUrl]); // üöß Deps are correct but they change too often\n  useEffect(() => {\n  const url = getFetchUrl('redux');\n  // ... Fetch data and do something ...\n  }, [getFetchUrl]); // üöß Deps are correct but they change too often\n  // ...\n}\nA tempting solution to this is to just skip the getFetchUrl function in the deps list. However, I don‚Äôt think it‚Äôs a good solution. This makes it difficult to notice when we are adding a change to the data flow that needs to be handled by an effect. This leads to bugs like the ‚Äúnever updating interval‚Äù we saw earlier.\nInstead, there are two other solutions that are simpler.\nFirst of all, if a function doesn‚Äôt use anything from the component scope, you can hoist it outside the component and then freely use it inside your effects:\n// ‚úÖ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\nfunction SearchResults() {\n  useEffect(() => {\n  const url = getFetchUrl('react');\n  // ... Fetch data and do something ...\n  }, []); // ‚úÖ Deps are OK\n  useEffect(() => {\n  const url = getFetchUrl('redux');\n  // ... Fetch data and do something ...\n  }, []); // ‚úÖ Deps are OK\n  // ...\n}\nThere‚Äôs no need to specify it in deps because it‚Äôs not in the render scope and can‚Äôt be affected by the data flow. It can‚Äôt accidentally depend on props or state.\nAlternatively, you can wrap it into the useCallback Hook:\nfunction SearchResults() {\n  // ‚úÖ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback((query) => {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []);  // ‚úÖ Callback deps are OK\n  useEffect(() => {\n  const url = getFetchUrl('react');\n  // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ‚úÖ Effect deps are OK\n  useEffect(() => {\n  const url = getFetchUrl('redux');\n  // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ‚úÖ Effect deps are OK\n  // ...\n}\nuseCallback is essentially like adding another layer of dependency checks. It‚Äôs solving the problem on the other end ‚Äî rather than avoid a function dependency, we make the function itself only change when necessary.\nLet‚Äôs see why this approach is useful. Previously, our example showed two search results (for 'react' and 'redux' search queries). But let‚Äôs say we want to add an input so that you can search for an arbitrary query. So instead of taking query as an argument, getFetchUrl will now read it from local state.\nWe‚Äôll immediately see that it‚Äôs missing a query dependency:\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n  const getFetchUrl = useCallback(() => { // No query argument\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []); // üî¥ Missing dep: query\n  // ...\n}\nIf I fix my useCallback deps to include query, any effect with getFetchUrl in deps will re-run whenever the query changes:\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n  // ‚úÖ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ‚úÖ Callback deps are OK\n  useEffect(() => {\n  const url = getFetchUrl();\n  // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ‚úÖ Effect deps are OK\n  // ...\n}\nThanks to useCallback, if query is the same, getFetchUrl also stays the same, and our effect doesn‚Äôt re-run. But if query changes, getFetchUrl will also change, and we will re-fetch the data. It‚Äôs a lot like when you change some cell in an Excel spreadsheet, and the other cells using it recalculate automatically.\nThis is just a consequence of embracing the data flow and the synchronization mindset. The same solution works for function props passed from parents:\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n  // ‚úÖ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n  const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n  // ... Fetch data and return it ...\n  }, [query]);  // ‚úÖ Callback deps are OK\n  return <Child fetchData={fetchData} />\n}\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n  useEffect(() => {\n  fetchData().then(setData);\n  }, [fetchData]); // ‚úÖ Effect deps are OK\n  // ...\n}\nSince fetchData only changes inside Parent when its query state changes, our Child won‚Äôt refetch the data until it‚Äôs actually necessary for the app.\nAre Functions Part of the Data Flow?\nInterestingly, this pattern is broken with classes in a way that really shows the difference between the effect and lifecycle paradigms. Consider this translation:\nclass Parent extends Component {\n  state = {\n  query: 'react'\n  };\n  fetchData = () => {\n  const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;\n  // ... Fetch data and do something ...\n  };\n  render() {\n  return <Child fetchData={this.fetchData} />;\n  }\n}\nclass Child extends Component {\n  state = {\n  data: null\n  };\n  componentDidMount() {\n  this.props.fetchData();\n  }\n  render() {\n  // ...\n  }\n}\nYou might be thinking: ‚ÄúCome on Dan, we all know that useEffect is like componentDidMount and componentDidUpdate combined, you can‚Äôt keep beating that drum!‚Äù Yet this doesn‚Äôt work even with componentDidUpdate:\nclass Child extends Component {\n  state = {\n  data: null\n  };\n  componentDidMount() {\n  this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n  // üî¥ This condition will never be true\n  if (this.props.fetchData !== prevProps.fetchData) {\n  this.props.fetchData();\n  }\n  }\n  render() {\n  // ...\n  }\n}\nOf course, fetchData is a class method! (Or, rather, a class property ‚Äî but that doesn‚Äôt change anything.) It‚Äôs not going to be different because of a state change. So this.props.fetchData will stay equal to prevProps.fetchData and we‚Äôll never refetch. Let‚Äôs just remove this condition then?\n  componentDidUpdate(prevProps) {\n  this.props.fetchData();\n  }\nOh wait, this fetches on every re-render. (Adding an animation above in the tree is a fun way to discover it.) Maybe let‚Äôs bind it to a particular query?\n  render() {\n  return <Child fetchData={this.fetchData.bind(this, this.state.query)} />;\n  }\nBut then this.props.fetchData !== prevProps.fetchData is always true, even if the query didn‚Äôt change! So we‚Äôll always refetch.\nThe only real solution to this conundrum with classes is to bite the bullet and pass the query itself into the Child component. The Child doesn‚Äôt actually end up using the query, but it can trigger a refetch when it changes:\nclass Parent extends Component {\n  state = {\n  query: 'react'\n  };\n  fetchData = () => {\n  const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;\n  // ... Fetch data and do something ...\n  };\n  render() {\n  return <Child fetchData={this.fetchData} query={this.state.query} />;\n  }\n}\nclass Child extends Component {\n  state = {\n  data: null\n  };\n  componentDidMount() {\n  this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n  if (this.props.query !== prevProps.query) {\n  this.props.fetchData();\n  }\n  }\n  render() {\n  // ...\n  }\n}\nOver the years of working with classes with React, I‚Äôve gotten so used to passing unnecessary props down and breaking encapsulation of parent components that I only realized a week ago why we had to do it.\nWith classes, function props by themselves aren‚Äôt truly a part of the data flow. Methods close over the mutable this variable so we can‚Äôt rely on their identity to mean anything. Therefore, even when we only want a function, we have to pass a bunch of other data around in order to be able to ‚Äúdiff‚Äù it. We can‚Äôt know whether this.props.fetchData passed from the parent depends on some state or not, and whether that state has just changed.\nWith useCallback, functions can fully participate in the data flow. We can say that if the function inputs changed, the function itself has changed, but if not, it stayed the same. Thanks to the granularity provided by useCallback, changes to props like props.fetchData can propagate down automatically.\nSimilarly, useMemo lets us do the same for complex objects:\nfunction ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState('pink');\n  const style = useMemo(() => ({ color }), [color]);\n  return <Child style={style} />;\n}\nI want to emphasize that putting useCallback everywhere is pretty clunky. It‚Äôs a nice escape hatch and it‚Äôs useful when a function is both passed down and called from inside an effect in some children. Or if you‚Äôre trying to prevent breaking memoization of a child component. But Hooks lend themselves better to avoiding passing callbacks down altogether.\nIn the above examples, I‚Äôd much prefer if fetchData was either inside my effect (which itself could be extracted to a custom Hook) or a top-level import. I want to keep the effects simple, and callbacks in them don‚Äôt help that. (‚ÄúWhat if some props.onComplete callback changes while the request was in flight?‚Äù) You can simulate the class behavior but that doesn‚Äôt solve race conditions.\nSpeaking of Race Conditions\nA classic data fetching example with classes might look like this:\nclass Article extends Component {\n  state = {\n  article: null\n  };\n  componentDidMount() {\n  this.fetchData(this.props.id);\n  }\n  async fetchData(id) {\n  const article = await API.fetchArticle(id);\n  this.setState({ article });\n  }\n  // ...\n}\nAs you probably know, this code is buggy. It doesn‚Äôt handle updates. So the second classic example you could find online is something like this:\nclass Article extends Component {\n  state = {\n  article: null\n  };\n  componentDidMount() {\n  this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n  if (prevProps.id !== this.props.id) {\n  this.fetchData(this.props.id);\n  }\n  }\n  async fetchData(id) {\n  const article = await API.fetchArticle(id);\n  this.setState({ article });\n  }\n  // ...\n}\nThis is definitely better! But it‚Äôs still buggy. The reason it‚Äôs buggy is that the request may come out of order. So if I‚Äôm fetching {id: 10}, switch to {id: 20}, but the {id: 20} request comes first, the request that started earlier but finished later would incorrectly overwrite my state.\nThis is called a race condition, and it‚Äôs typical in code that mixes async / await (which assumes something waits for the result) with top-down data flow (props or state can change while we‚Äôre in the middle of an async function).\nEffects don‚Äôt magically solve this problem, although they‚Äôll warn you if you try to pass an async function to the effect directly. (We‚Äôll need to improve that warning to better explain the problems you might run into.)\nIf the async approach you use supports cancellation, that‚Äôs great! You can cancel the async request right in your cleanup function.\nAlternatively, the easiest stopgap approach is to track it with a boolean:\nfunction Article({ id }) {\n  const [article, setArticle] = useState(null);\n  useEffect(() => {\n  let didCancel = false;\n  async function fetchData() {\n  const article = await API.fetchArticle(id);\n  if (!didCancel) {\n  setArticle(article);\n  }\n  }\n  fetchData();\n  return () => {\n  didCancel = true;\n  };\n  }, [id]);\n  // ...\n}\nThis article goes into more detail about how you can handle errors and loading states, as well as extract that logic into a custom Hook. I recommend you to check it out if you‚Äôre interested to learn more about data fetching with Hooks.\nRaising the Bar\nWith the class lifecycle mindset, side effects behave differently from the render output. Rendering the UI is driven by props and state, and is guaranteed to be consistent with them, but side effects are not. This is a common source of bugs.\nWith the mindset of useEffect, things are synchronized by default. Side effects become a part of the React data flow. For every useEffect call, once you get it right, your component handles edge cases much better.\nHowever, the upfront cost of getting it right is higher. This can be annoying. Writing synchronization code that handles edge cases well is inherently more difficult than firing one-off side effects that aren‚Äôt consistent with rendering.\nThis could be worrying if useEffect was meant to be the tool you use most of the time. However, it‚Äôs a low-level building block. It‚Äôs an early time for Hooks so everybody uses low-level ones all the time, especially in tutorials. But in practice, it‚Äôs likely the community will start moving to higher-level Hooks as good APIs gain momentum.\nI‚Äôm seeing different apps create their own Hooks like useFetch that encapsulates some of their app‚Äôs auth logic or useTheme which uses theme context. Once you have a toolbox of those, you don‚Äôt reach for useEffect that often. But the resilience it brings benefits every Hook built on top of it.\nSo far, useEffect is most commonly used for data fetching. But data fetching isn‚Äôt exactly a synchronization problem. This is especially obvious because our deps are often []. What are we even synchronizing?\nIn the longer term, Suspense for Data Fetching will allow third-party libraries to have a first-class way to tell React to suspend rendering until something async (anything: code, data, images) is ready.\nAs Suspense gradually covers more data fetching use cases, I anticipate that useEffect will fade into background as a power user tool for cases when you actually want to synchronize props and state to some side effect. Unlike data fetching, it handles this case naturally because it was designed for it. But until then, custom Hooks like shown here are a good way to reuse data fetching logic.\nIn Closing\nNow that you know pretty much everything I know about using effects, check out the TLDR in the beginning. Does it make sense? Did I miss something? (I haven‚Äôt run out of paper yet!)\nI‚Äôd love to hear from you on Twitter! Thanks for reading.Pay what you likeDiscuss on Bluesky¬†¬†¬∑¬†¬†Edit on GitHub \n\n,## Webpage #6:\n useEffect is one of those React/Preact hooks that most people have a love/hate relationship with, but like it or not, it's good to understand how it works. This is not the first blog post on the subject, and it's certainly not going to be the last, but hopefully I can explain some things to you about when (and why!) it runs in your applications for you to use as a reference! \n  Please tell my friend what useEffect actually is \nYour friend asks a good question! First of all, let's talk about side effects in your applications. When I say side effect, I mean it is something that happens when other things are changing. For example, if I were to have a very simple add function: \nfunction add(x, y) {\n  return x + y\n} \n  Enter fullscreen mode\n  Exit fullscreen mode\nI could make a side effect of some other variable changing, like so: \nlet z = 10\nfunction add(x, y) {\n  z = z + x // this is the side effect, it does not change the return value\n  return x + y\n} \n  Enter fullscreen mode\n  Exit fullscreen mode\nChanging that z variable in here does not change the return value of the function, it's just a side effect of adding x and y! Now in React/Preact, it's a bit more complex, and side effects aren't always a good thing. And useEffect is \"usually\" for side effects. Developer David Khourshid aptly said that useEffect should probably have been named useSynchronize, because rather than it being, \"an extra thing that should happen when state changes happen,\" it should be more like, \"things that happen to stay in sync with certain state changes.\"  \n  When does useEffect get called? \nSo, it does get a little hairy because useEffects behavior has changed a bit across framework updates, but at a high level: it's called on component mount, and whenever anything in the dependency array changes. I'll explain this more deeply! So using this as our base: \nuseEffect(() => {\n  // your fetch call, changes, etc\n  return () => {\n  // clean-up\n  }\n}, [dependencyArray]) // we're staying in sync with this \n  Enter fullscreen mode\n  Exit fullscreen mode\n  The dependency array \nThat second parameter of useEffect is called the dependency array. There's 3 things that can happen here: \nIf the dependency array is empty, useEffect is only called once (note: this has changed in React 18 in development and strict mode because of Suspense things, but this is how it is for Preact and pre-React 18 and I will talk about a workaround later in this post)\nIf it doesn't exist (like it's omitted entirely), then useEffect is called on every state change\nIf it has a variable in it, then useEffect is called when that variable changes \nIf that dependency array is populated, you can think of the useEffect function as staying \"in sync\" with the variables in the array. \n  The return function \nWhenever useEffect is about to be called again, or whenever the component is about to be dismounted/destroyed, the \"clean-up function\" is called. Or to rephrase, React/Preact calls the clean-up functions when a component unmounts, or when an update is made and it needs to \"cancel\" the previous effect. As another, more filled out, example: \nuseEffect(() => {\n  let isCurrent = true\n  fetchUser(uid).then((user) => {\n  if (isCurrent) setUser(user)\n  })\n  return () => {\n  isCurrent = false\n  }\n}, [uid]) \n  Enter fullscreen mode\n  Exit fullscreen mode\nThis might look a little confusing, but the way it works is when the component is mounted, the component will fetch the user. If uid hasn't changed and the component stays mounted, setUser will be called. If uid changes in that time, isCurrent will be set to false, so setUser won't be called for that out-of-date HTTP call. \n  Stopping useEffect from being called on mount \nBesides controlling the dependency array variables, the only other thing you might want to consider is saying, \"hey, I don't want this effect to be called on mount, but ONLY on updates in the dependency array.\" This is weird but it happens. For this particular case, you'll want to bring in the useRef hook. I'm not going to explain what that hook does here because that deserves its own blog post (this one is pretty good from Robin Wieruch). Let's assume you have some state variable called syncWithMe that you want to stay in sync with: \nconst hasMounted = useRef(false); useEffect(() => {\n  if (hasMounted.current) {\n  // code here only runs when syncWithMe changes!\n  } else {\n  hasMounted.current = true;\n  }\n}, [syncWithMe]); \n  Enter fullscreen mode\n  Exit fullscreen mode\nThis is called a \"ref flag\"! In this example, hasMounted acts as an instance variable that doesn't cause re-renders or effect changes (because it isn't a state variable). So, you set it to true when the component mounts, and then whenever syncWithMe changes, the effect function is called. \n  Having useEffect called only on mount in React 18+ \nBecause of how the new Suspense functionality works and a bunch of other changes that happened in React 18, useEffect needs to be manipulated more to run just once in development and strict mode (it should be fine in production but eh, this is still worth talking about). It'll look a lot like our previous example, but opposite: \nconst hasMounted = useRef(false); useEffect(() => {\n  if (hasMounted.current) { return; }  // do something  hasMounted.current = true;\n}, []); \n  Enter fullscreen mode\n  Exit fullscreen mode\n  What if I don't want to use useEffect at all? \nThen I think you should probably watch or read some thought-leadery content around why it's bad. Heh. useEffect isn't bad, it just has its own time and place and a lot of people have Opinions‚Ñ¢ about how it should be used. I do recommend watching this talk about useEffect in general. It is titled \"Goodbye, useEffect\" (once again from David Khourshid, who I referenced above), and explains some nuances of when you should and shouldn't use it. Hopefully this post was useful for you as a reference! \n\n\n  </teaching_info>\n\n  ===\n\n  Please return answer in markdown. It is very important for my career that you follow these instructions. Here is the topic to educate on:\n    "
  },
  {
    "role": "user",
    "content": "code of useffect"
  }
]